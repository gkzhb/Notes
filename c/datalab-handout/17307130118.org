#+TITLE: datalab 实验报告

* bitAnd

题目只提供两种操作符，考虑到 =&= 与 =|= 具有对称性，所以通过取反来实现。

* getByte

考虑到二进制的 n 只有两位，而且经过思考发现，n 的最低位是否为1决定了 x 是否需要向右移位 8 位；而 n 的第二位决定了 x 是否需要向右移位 16 位。可以通过与操作获取 n 的对应位，而对应的 4 和 8 也可由 2 或 1 移位而得到，所以问题基本得到解决。
开始写的代码是这样的：

#+BEGIN_SRC C
int getByte(int x, int n) {
  x = x >> ((n & 0x2) << 3);
  x = x >> ((n & 0x1) << 2);
  return x & 0xff;
}
#+END_SRC

第三行这里只位移了 2 位，开始没发现这个地方错了，一直纠结于操作数多了一个。后来发现其实也应该移位 3 位，于是对应的位移操作可以合并，从而节约一个操作符，刚好符合题目条件。

* logicalShift

我最初的想法就是先保存符号位，并将符号位置 0，然后直接移位，最后将符号位放到移位后的位置。
开始一直通过来回移位的方式移动符号位，但是总会移出边界变成 0。最终发现可以通过用反码取得 32 - n 的值，然后从低位向高位移动到符号位的位置。

* bitCount

这题一直没有找到解决方法，只想到每一位相加的方式，当然一定会超操作数，所以写的代码是这样的：

#+BEGIN_SRC C
int bitCount(int x) {
  int ans;
  ans = x & 0x1 + (x & 0x2) >> 1 + (x & 0x4) >> 2 + (x & 0x8) >> 3 + (x & 0x10) >> 4 + (x & 0x20) >> 5 + (x & 0x40) >> 6 + (x & 0x80) >> 7;
  x = x >> 8;
  ans = ans + x & 0x1 + (x & 0x2) >> 1 + (x & 0x4) >> 2 + (x & 0x8) >> 3 + (x & 0x10) >> 4 + (x & 0x20) >> 5 + (x & 0x40) >> 6 + (x & 0x80) >> 7;
  x = x >> 8;
  ans = ans + x & 0x1 + (x & 0x2) >> 1 + (x & 0x4) >> 2 + (x & 0x8) >> 3 + (x & 0x10) >> 4 + (x & 0x20) >> 5 + (x & 0x40) >> 6 + (x & 0x80) >> 7;
  x = x >> 8;
  ans = ans + x & 0x1 + (x & 0x2) >> 1 + (x & 0x4) >> 2 + (x & 0x8) >> 3 + (x & 0x10) >> 4 + (x & 0x20) >> 5 + (x & 0x40) >> 6 + (x & 0x80) >> 7;
  return ans;
}
#+END_SRC

而且缺少括号，由于 =+= 优先级高于 =>>= 所以代码结果都完全不对。
