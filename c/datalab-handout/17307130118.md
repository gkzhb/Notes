# datalab 实验报告

## bitAnd

题目只提供两种操作符，考虑到 `&` 与 `|` 具有对称性，所以通过取反来实现。

## getByte

考虑到二进制的 n 只有两位，而且经过思考发现，n 的最低位是否为1决定了 x 是否需要向右移位 8 位；而 n 的第二位决定了 x 是否需要向右移位 16 位。可以通过与操作获取 n 的对应位，而对应的 8 和 16 也可由 2 或 1 移位而得到，所以问题基本得到解决。 开始写的代码是这样的：

``` c
int getByte(int x, int n) {
  x = x >> ((n & 0x2) << 3);
  x = x >> ((n & 0x1) << 2);
  return x & 0xff;
}
```

第三行这里只位移了 2 位，开始没发现这个地方错了，一直纠结于操作数多了一个。后来发现其实也应该移位 3 位，于是对应的位移操作可以合并，从而节约一个操作符，刚好符合题目条件。

``` c
int getByte(int x, int n) {
  n = n << 3;
  x = x >> (n & 0x10);
  x = x >> (n & 0x8);
  return x & 0xff;
}
```

找不会做的题目的答案的时候，发现这个还能简化步骤，两步 x 的 移位可以合并。

## logicalShift

我最初的想法就是先保存符号位，并将符号位置 0，然后直接移位，最后将符号位放到移位后的位置。
开始一直通过来回移位的方式移动符号位，但是总会移出边界变成 0。最终发现可以通过用反码取得 32 - n 的值，然后从低位向高位移动到符号位的位置。

## bitCount

这题一直没有找到解决方法，只想到每一位相加的方式，当然一定会超操作数，所以写的代码是这样的：

``` c
int bitCount(int x) {
  int ans;
  ans = x & 0x1 + (x & 0x2) >> 1 + (x & 0x4) >> 2 
    + (x & 0x8) >> 3 + (x & 0x10) >> 4 
    + (x & 0x20) >> 5 + (x & 0x40) >> 6 
    + (x & 0x80) >> 7;
  x = x >> 8;
  ans = ans + x & 0x1 + (x & 0x2) >> 1 
    + (x & 0x4) >> 2 + (x & 0x8) >> 3 
    + (x & 0x10) >> 4 + (x & 0x20) >> 5 
    + (x & 0x40) >> 6 + (x & 0x80) >> 7;
  x = x >> 8;
  ans = ans + x & 0x1 + (x & 0x2) >> 1 
    + (x & 0x4) >> 2 + (x & 0x8) >> 3 
    + (x & 0x10) >> 4 + (x & 0x20) >> 5 
    + (x & 0x40) >> 6 + (x & 0x80) >> 7;
  x = x >> 8;
  ans = ans + x & 0x1 + (x & 0x2) >> 1 
    + (x & 0x4) >> 2 + (x & 0x8) >> 3 
    + (x & 0x10) >> 4 + (x & 0x20) >> 5 
    + (x & 0x40) >> 6 + (x & 0x80) >> 7;
  return ans;
}
```

而且缺少括号，由于 `+` 优先级高于 `>>` 所以代码结果都完全不对。

## bang

考虑到这道题的操作符数目限制，肯定要节约操作步骤，所以可以通过每次将位的前一半与后一半取或，重复操作便可在较少操作的情况下完成，最后取异或就得到结果。

## tmin

最小 int 类型的内存表示就是 0x80000000，通过移位很容易得到。

## fitsBits

这题最麻烦的一点在于正数和负数表示范围相差一个数，而且操作符数目限制比较严格。如果先向右移位再判断剩下的有没有数字，关键是如何整合起来正负数的补码的不同。我想不出很好的处理办法。

## divpwr2

这道题关键在于负数的处理：一方面不能整除的负数直接移位结果会相差 1，所以需要加上一个数，另一方面，要保证正数在处理的时候不会加上这个数。但是一直没有实现第二点。

## negate

取反，按照 取反加 1 原理做就可以做出来了（取反的同时也顺带把符号位也取反了）

## isLessOrEqual

老师后来讲的 compq 命令与这个的实现类似，需要判断是否同号，以及判断是否溢出

## ilog2

这个应该是找出最高位的 1 在什么位置，不允许用循环 条件，没想出来怎么实现

## float_neg

这题关键是找出 NaN 的情况，按照 NaN 的条件做然后调试就做出来了

## float_i2f

需要讨论情况很多，而且还需要“四舍五入”，进位还没能完成

## float_twice

开始以为和前面一样需要区分 NaN，做到最后发现 NaN 的情况和另一种情况可以合并，也就没必要判断 NaN 了。
这题主要是先判断指数是否为 0以及精度首位是否为 0，若两者都为 0 则直接将精度向左移位 1 位，否则将指数加 1。
有个特殊情况是指数满了的时候不加 1，否则会溢出，这种情况与 NaN 的判断可以合并在一起。

## 没做出来的题

* bitCount
* fitsBits
* divpwr2
* ilog2
* float_i2f

参考博客：https://blog.csdn.net/lwfcgz/article/details/8515188